/*
 * generated by Xtext
 */
package org.nanosite.remix.generator

import java.io.BufferedReader
import java.io.File
import java.io.FileNotFoundException
import java.io.FileReader
import java.io.IOException
import java.util.HashMap
import java.util.Map
import java.util.Properties
import org.eclipse.core.runtime.Path
import org.eclipse.emf.common.CommonPlugin
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.plugin.EcorePlugin
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.nanosite.remix.remix.Collection
import org.nanosite.remix.remix.Configuration
import org.nanosite.remix.remix.DependencyType
import org.nanosite.remix.remix.Model
import org.nanosite.remix.remix.Module
import org.nanosite.remix.remix.ModuleRef
import org.nanosite.remix.remix.Part
import org.nanosite.remix.remix.Presentation

class RemixGenerator implements IGenerator {
	
	static final String RESOURCE_FOLDER = "resources" 

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		println("RemixGenerator running...")
		for(m : resource.allContents.toIterable.filter(typeof(Model))) {
//			var filebase = resource.URI.segments.last
//			var dotfile = filebase.replace('.', '_') + ".txt"
//			if (m.genPath!=null && !m.genPath.empty)
//				dotfile = m.genPath + "/" + dotfile
			for(pres : m.presentations) {
// 				fsa.generateFile(pres.name + ".txt", pres.generate)
				val targetDir = pres.getTargetFolder(resource)
				FileHelper::save(targetDir, "index.html", pres.generate(targetDir).toString)
 			}
 		}
	}
	
	def private generate (Presentation pres, String targetDir) {
		// prepare some substitutions
		var substitutions = new HashMap<String,String>
		substitutions.put("%%TITLE%%", pres.title)
		substitutions.put("%%DESCRIPTION%%",
			if (pres.description!=null) pres.description else "reveal.js presentation generated by remix"
		)
		substitutions.put("%%THEME%%",
			if (pres.theme!=null) pres.theme.name else "default"
		)
		substitutions.put("%%AUTHOR%%", pres.author)

		substitutions.put("%%CSS_NEEDS%%", pres.neededCSS)
		
		// generate html
		val out = pres.genAll(substitutions)
		
		// copy resources from used modules
		for(m : pres.parts.map[modules].flatten.filter[isSelected(pres.config)]) {
			val srcdir = m.module.parentFolder + File::separator + RESOURCE_FOLDER
			val src = new File(srcdir)
			val targetdir = targetDir + File::separator + RESOURCE_FOLDER
			println("copy from" + sep + "  " + srcdir + " to" + sep + "  " + targetdir)
			if (src.exists && src.directory) {
				FileHelper::copyFolder(src, new File(targetdir.toString))
			}
		}
		
		// return generated html
		return out
	}

	def private isSelected (ModuleRef m, Configuration cfg) {
		if (m.selector==null)
			true
		else {
			if (cfg==null)
				false
			else
				cfg.active==m.selector
		}
	}
	
	def private genAll (Presentation pres, Map<String,String> substitutions) '''
		«FOR p : pres.parts»
		«IF p.title!=null»
			«p.genTitle(pres.partattr)»
		«ELSE»
			«IF p.overview»
				«pres.genOverview(pres.partattr)»
			«ENDIF»
		«ENDIF»
		«p.genPartContents(substitutions, pres.config)»
		«ENDFOR»
	'''

	def private genOverview (Presentation pres, String attr) '''
		<!-- Overview generated by remix -->
		<section«IF attr!=null» «attr»«ENDIF»>
			<h2>Overview</h2>
			<ol>
				«FOR p : pres.parts.filter[title!=null]»
				<li>«p.title»</li>
				«ENDFOR»
			</ol>
		</section>
		
	'''
	
	def private genTitle (Part part, String attr) '''
		<section«IF attr!=null» «attr»«ENDIF»>
			<h2>«part.title»</h2>
			<hr>
			«IF part.image!=null»
			<img width="400" src="«RESOURCE_FOLDER»/«part.image»">
			«ENDIF»
		</section>

	'''	

	def private genPartContents (Part part, Map<String,String> substitutions, Configuration cfg) '''
		«FOR m : part.modules.filter[isSelected(cfg)].map[module]»
		<!-- «m.name» @ «m.filename» -->
		«m.filename.loadFile.replace(substitutions)»

		«ENDFOR»
	'''
	
	def private String getTargetFolder (Presentation it, Resource res) {
		val targetAbs =
			if (target!=null) {
				// get target folder directly from presentation (deprecated)
				val f = new File(target)
				if (f.absolute) {
					target
				} else {
					parentFolder + File::separator + target
				}
			} else {
				// get target folder from properties file
				val folder = res.getProperty("target")
				if (folder==null)
					throw new RuntimeException("Cannot get target folder from properties file")
				folder
			}
		targetAbs + File::separator + name
	}
	
	def private getParentFolder (Module it) {
		if (collection.path!=null)
			collection.path
		else {
			collection.parentFolderAux
		}
	}

	def private getParentFolder (Presentation it) {
		parentFolderAux
	}
	
	def private getParentFolderAux (EObject it) {
		val folder = CommonPlugin::resolve(eResource.URI).trimSegments(1)
		folder.path
	}

	def private getCollection (Module it) {
		(eContainer as Collection)
	}

	def private String getFilename (Module it) {
		parentFolder + File::separator + file
	}
	
	def private String getNeededCSS (Presentation it) '''
		«FOR css : collectNeededCSS»
		<link rel="stylesheet" href="«css.file»">
		«ENDFOR»
	'''

	def private collectNeededCSS (Presentation pres) {
		pres.parts.map[modules].flatten
			.filter[isSelected(pres.config)]
			.map[module]
			.map[dependencies].flatten.toSet
			.filter[type==DependencyType::CSS]
	}

	def private loadFile (String filename) {
		var file = new File(filename)
 		var content = new StringBuffer
 		var BufferedReader reader = null
 
 		try {
  			reader = new BufferedReader(new FileReader(file))
  			var String s = null
 
			while ((s = reader.readLine()) != null) {
				content.append(s).append(sep)
			}
		} catch (FileNotFoundException e) {
 			throw e
		} catch (IOException e) {
 			throw e
		} finally {
			try {
				if (reader != null) {
					reader.close
				}
			} catch (IOException e) {
			}
		}
		return content.toString
	}
	
	def private replace (String in, Map<String, String> subst) {
		var String out = in
		for(s : subst.keySet) {
			out = out.replaceAll(s, subst.get(s))	
		}
		out
	}
	
	def private getSep() {
		System::getProperty("line.separator")
	}

	/**
	 * Get property from properties file.
	 * 
	 * The file should be located in the same folder as the resource res,
	 * has the same basename, but it has the extension 'properties'.
	 */
	def private getProperty(Resource res, String prop) {
		val uri = res.URI.trimFileExtension.appendFileExtension("properties")
		val props = new Properties
		val path = uri.toPlatformString(true)
		val workspaceRoot = EcorePlugin::getWorkspaceRoot
		val file = workspaceRoot.getFile(new Path(path))
		val inputStream = file.contents
		if (inputStream==null)
			throw new RuntimeException("Cannot read properties file '" + uri + "'")

		// load properties file 
		props.load(inputStream)
		
		// get value from properties file
		val value = props.getProperty(prop)
		if (value==null)
			throw new RuntimeException("Missing '" + prop + "' property in properties file '" + uri + "'")

		value
	}

}

